# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import datetime
import decimal

from builtins import bool as _bool, float as _float, int as _int, str as _str
from typing import (
    Any,
    Literal,
    TypeVar,
    Union,
)

from typing_extensions import TypedDict

LiteralString = str
# -- template types.py.jinja --

from . import _types
from .utils import _NoneType

# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    list[Any],
    dict[None, Any],
    dict[bool, Any],
    dict[float, Any],
    dict[int, Any],
    dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': list[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': list[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': list[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': list[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': list[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': list[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': list[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': list[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': list[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': list[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': list[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': list[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': list[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': list[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': list[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': list[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': list[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': list[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': list[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': list[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


class BooleanFilterRecursive4(TypedDict, total=False):
    equals: bool


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': list[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': list[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': list[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': list[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': list[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': list[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': list[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': list[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': list[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': list[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': list[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': list[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': list[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': list[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': list[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': list[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': list[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': list[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': list[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': list[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': list['fields.Base64'],
        'not_in': list['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': list['fields.Base64'],
        'not_in': list['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': list['fields.Base64'],
        'not_in': list['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': list['fields.Base64'],
        'not_in': list['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': list['fields.Base64'],
        'not_in': list['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': list[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': list[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': list[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': list[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': list[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': list[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': list[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': list[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': list[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': list[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: list[_str] | None


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: list[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: list[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: list[_str]


class _StringListUpdatePush(TypedDict):
    push: list[_str]


StringListUpdate = Union[
    list[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: list['fields.Base64'] | None


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: list['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: list['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: list['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: list['fields.Base64']


BytesListUpdate = Union[
    list['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: list[datetime.datetime] | None


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: list[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: list[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: list[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: list[datetime.datetime]


DateTimeListUpdate = Union[
    list[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: list[_bool] | None


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: list[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: list[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: list[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: list[_bool]


BooleanListUpdate = Union[
    list[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: list[_int] | None


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: list[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: list[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: list[_int]


class _IntListUpdatePush(TypedDict):
    push: list[_int]


IntListUpdate = Union[
    list[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: list[_int] | None


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: list[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: list[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: list[_int]


class _BigIntListUpdatePush(TypedDict):
    push: list[_int]


BigIntListUpdate = Union[
    list[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: list[_float] | None


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: list[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: list[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: list[_float]


class _FloatListUpdatePush(TypedDict):
    push: list[_float]


FloatListUpdate = Union[
    list[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: list['fields.Json'] | None


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: list['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: list['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: list['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: list['fields.Json']


JsonListUpdate = Union[
    list['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: list[decimal.Decimal] | None


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: list[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: list[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: list[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: list[decimal.Decimal]


DecimalListUpdate = Union[
    list[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _productstypeenumListFilterEqualsInput(TypedDict):
    equals: list['enums.productstypeenum'] | None


class _productstypeenumListFilterHasInput(TypedDict):
    has: 'enums.productstypeenum'


class _productstypeenumListFilterHasEveryInput(TypedDict):
    has_every: list['enums.productstypeenum']


class _productstypeenumListFilterHasSomeInput(TypedDict):
    has_some: list['enums.productstypeenum']


class _productstypeenumListFilterIsEmptyInput(TypedDict):
    is_empty: bool


productstypeenumListFilter = Union[
    _productstypeenumListFilterHasInput,
    _productstypeenumListFilterEqualsInput,
    _productstypeenumListFilterHasSomeInput,
    _productstypeenumListFilterIsEmptyInput,
    _productstypeenumListFilterHasEveryInput,
]


class _productstypeenumListUpdateSet(TypedDict):
    set: list['enums.productstypeenum']


class _productstypeenumListUpdatePush(TypedDict):
    push: list['enums.productstypeenum']


productstypeenumListUpdate = Union[
    list['enums.productstypeenum'],
    _productstypeenumListUpdateSet,
    _productstypeenumListUpdatePush,
]


# alembic_version types

class alembic_versionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the alembic_version create method"""


class alembic_versionCreateInput(alembic_versionOptionalCreateInput):
    """Required arguments to the alembic_version create method"""
    version_num: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class alembic_versionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the alembic_version create method, without relations"""


class alembic_versionCreateWithoutRelationsInput(alembic_versionOptionalCreateWithoutRelationsInput):
    """Required arguments to the alembic_version create method, without relations"""
    version_num: _str

class alembic_versionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'alembic_versionCreateWithoutRelationsInput'
    where: 'alembic_versionWhereUniqueInput'

class alembic_versionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'alembic_versionCreateWithoutRelationsInput'
    connect: 'alembic_versionWhereUniqueInput'
    connect_or_create: 'alembic_versionConnectOrCreateWithoutRelationsInput'


class alembic_versionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['alembic_versionCreateWithoutRelationsInput', list['alembic_versionCreateWithoutRelationsInput']]
    connect: Union['alembic_versionWhereUniqueInput', list['alembic_versionWhereUniqueInput']]
    connect_or_create: Union['alembic_versionConnectOrCreateWithoutRelationsInput', list['alembic_versionConnectOrCreateWithoutRelationsInput']]

class _alembic_versionWhereUnique_version_num_Input(TypedDict, total=True):
    version_num: '_str'

alembic_versionWhereUniqueInput = _alembic_versionWhereUnique_version_num_Input


class alembic_versionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    version_num: _str


class alembic_versionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    version_num: _str


class alembic_versionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: list['alembic_versionCreateWithoutRelationsInput']
    connect: list['alembic_versionWhereUniqueInput']
    connect_or_create: list['alembic_versionConnectOrCreateWithoutRelationsInput']
    set: list['alembic_versionWhereUniqueInput']
    disconnect: list['alembic_versionWhereUniqueInput']
    delete: list['alembic_versionWhereUniqueInput']

    # TODO
    # update: List['alembic_versionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['alembic_versionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['alembic_versionScalarWhereInput']
    # upsert: List['alembic_versionUpserteWithWhereUniqueWithoutRelationsInput']


class alembic_versionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'alembic_versionCreateWithoutRelationsInput'
    connect: 'alembic_versionWhereUniqueInput'
    connect_or_create: 'alembic_versionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'alembic_versionUpdateInput'
    # upsert: 'alembic_versionUpsertWithoutRelationsInput'


class alembic_versionUpsertInput(TypedDict):
    create: 'alembic_versionCreateInput'
    update: 'alembic_versionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


class _alembic_version_version_num_OrderByInput(TypedDict, total=True):
    version_num: 'SortOrder'

class _alembic_version_RelevanceInner(TypedDict, total=True):
    fields: 'list[alembic_versionScalarFieldKeys]'
    search: 'str'
    sort: 'SortOrder'

class _alembic_version_RelevanceOrderByInput(TypedDict, total=True):
    _relevance: '_alembic_version_RelevanceInner'

alembic_versionOrderByInput = Union[
    '_alembic_version_version_num_OrderByInput',
    '_alembic_version_RelevanceOrderByInput',
]



# recursive alembic_version types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

alembic_versionRelationFilter = TypedDict(
    'alembic_versionRelationFilter',
    {
        'is': 'dict[str, Any]',
        'is_not': 'dict[str, Any]',
    },
    total=False,
)


class alembic_versionListRelationFilter(TypedDict, total=False):
    some: 'dict[str, Any]'
    none: 'dict[str, Any]'
    every: 'dict[str, Any]'


class alembic_versionInclude(TypedDict, total=False):
    """alembic_version relational arguments"""


    

class alembic_versionIncludeFromalembic_version(TypedDict, total=False):
    """Relational arguments for alembic_version"""


class alembic_versionIncludeFromalembic_versionRecursive1(TypedDict, total=False):
    """Relational arguments for alembic_version"""


class alembic_versionIncludeFromalembic_versionRecursive2(TypedDict, total=False):
    """Relational arguments for alembic_version"""


class alembic_versionIncludeFromalembic_versionRecursive3(TypedDict, total=False):
    """Relational arguments for alembic_version"""


class alembic_versionIncludeFromalembic_versionRecursive4(TypedDict, total=False):
    """Relational arguments for alembic_version"""

    

class alembic_versionArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class alembic_versionArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class alembic_versionArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class alembic_versionArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class alembic_versionArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    
    

class FindManyalembic_versionArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class FindManyalembic_versionArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class FindManyalembic_versionArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class FindManyalembic_versionArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class FindManyalembic_versionArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    
    

class licenseIncludeFromalembic_version(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    users: Union[bool, 'usersArgsFromalembic_versionRecursive1']
    products: Union[bool, 'productsArgsFromalembic_versionRecursive1']


class licenseIncludeFromalembic_versionRecursive1(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    users: Union[bool, 'usersArgsFromalembic_versionRecursive2']
    products: Union[bool, 'productsArgsFromalembic_versionRecursive2']


class licenseIncludeFromalembic_versionRecursive2(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    users: Union[bool, 'usersArgsFromalembic_versionRecursive3']
    products: Union[bool, 'productsArgsFromalembic_versionRecursive3']


class licenseIncludeFromalembic_versionRecursive3(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    users: Union[bool, 'usersArgsFromalembic_versionRecursive4']
    products: Union[bool, 'productsArgsFromalembic_versionRecursive4']


class licenseIncludeFromalembic_versionRecursive4(TypedDict, total=False):
    """Relational arguments for alembic_version"""

    

class licenseArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'licenseIncludeFromlicenseRecursive1'


class licenseArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'licenseIncludeFromlicenseRecursive2'


class licenseArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'licenseIncludeFromlicenseRecursive3'


class licenseArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'licenseIncludeFromlicenseRecursive4'


class licenseArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    
    

class FindManylicenseArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive1'


class FindManylicenseArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive2'


class FindManylicenseArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive3'


class FindManylicenseArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive4'


class FindManylicenseArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    
    

class productsIncludeFromalembic_version(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive1']


class productsIncludeFromalembic_versionRecursive1(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive2']


class productsIncludeFromalembic_versionRecursive2(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive3']


class productsIncludeFromalembic_versionRecursive3(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive4']


class productsIncludeFromalembic_versionRecursive4(TypedDict, total=False):
    """Relational arguments for alembic_version"""

    

class productsArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'productsIncludeFromproductsRecursive1'


class productsArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'productsIncludeFromproductsRecursive2'


class productsArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'productsIncludeFromproductsRecursive3'


class productsArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'productsIncludeFromproductsRecursive4'


class productsArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    
    

class FindManyproductsArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive1'


class FindManyproductsArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive2'


class FindManyproductsArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive3'


class FindManyproductsArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive4'


class FindManyproductsArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    
    

class usersIncludeFromalembic_version(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive1']


class usersIncludeFromalembic_versionRecursive1(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive2']


class usersIncludeFromalembic_versionRecursive2(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive3']


class usersIncludeFromalembic_versionRecursive3(TypedDict, total=False):
    """Relational arguments for alembic_version"""
    licenses: Union[bool, 'FindManylicenseArgsFromalembic_versionRecursive4']


class usersIncludeFromalembic_versionRecursive4(TypedDict, total=False):
    """Relational arguments for alembic_version"""

    

class usersArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'usersIncludeFromusersRecursive1'


class usersArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'usersIncludeFromusersRecursive2'


class usersArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'usersIncludeFromusersRecursive3'


class usersArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    include: 'usersIncludeFromusersRecursive4'


class usersArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    
    

class FindManyusersArgsFromalembic_version(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive1'


class FindManyusersArgsFromalembic_versionRecursive1(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive2'


class FindManyusersArgsFromalembic_versionRecursive2(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive3'


class FindManyusersArgsFromalembic_versionRecursive3(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive4'


class FindManyusersArgsFromalembic_versionRecursive4(TypedDict, total=False):
    """Arguments for alembic_version"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    


FindManyalembic_versionArgs = FindManyalembic_versionArgsFromalembic_version
FindFirstalembic_versionArgs = FindManyalembic_versionArgsFromalembic_version


    

class alembic_versionWhereInput(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['alembic_versionWhereInputRecursive1', List['alembic_versionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: list['alembic_versionWhereInputRecursive1']
    OR: list['alembic_versionWhereInputRecursive1']
    NOT: list['alembic_versionWhereInputRecursive1']


class alembic_versionWhereInputRecursive1(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['alembic_versionWhereInputRecursive2', List['alembic_versionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: list['alembic_versionWhereInputRecursive2']
    OR: list['alembic_versionWhereInputRecursive2']
    NOT: list['alembic_versionWhereInputRecursive2']


class alembic_versionWhereInputRecursive2(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['alembic_versionWhereInputRecursive3', List['alembic_versionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: list['alembic_versionWhereInputRecursive3']
    OR: list['alembic_versionWhereInputRecursive3']
    NOT: list['alembic_versionWhereInputRecursive3']


class alembic_versionWhereInputRecursive3(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['alembic_versionWhereInputRecursive4', List['alembic_versionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: list['alembic_versionWhereInputRecursive4']
    OR: list['alembic_versionWhereInputRecursive4']
    NOT: list['alembic_versionWhereInputRecursive4']


class alembic_versionWhereInputRecursive4(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringFilter']



# aggregate alembic_version types


    

class alembic_versionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['alembic_versionScalarWhereWithAggregatesInputRecursive1']
    OR: list['alembic_versionScalarWhereWithAggregatesInputRecursive1']
    NOT: list['alembic_versionScalarWhereWithAggregatesInputRecursive1']


class alembic_versionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['alembic_versionScalarWhereWithAggregatesInputRecursive2']
    OR: list['alembic_versionScalarWhereWithAggregatesInputRecursive2']
    NOT: list['alembic_versionScalarWhereWithAggregatesInputRecursive2']


class alembic_versionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['alembic_versionScalarWhereWithAggregatesInputRecursive3']
    OR: list['alembic_versionScalarWhereWithAggregatesInputRecursive3']
    NOT: list['alembic_versionScalarWhereWithAggregatesInputRecursive3']


class alembic_versionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['alembic_versionScalarWhereWithAggregatesInputRecursive4']
    OR: list['alembic_versionScalarWhereWithAggregatesInputRecursive4']
    NOT: list['alembic_versionScalarWhereWithAggregatesInputRecursive4']


class alembic_versionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """alembic_version arguments for searching"""
    version_num: Union[_str, 'types.StringWithAggregatesFilter']



class alembic_versionGroupByOutput(TypedDict, total=False):
    version_num: _str
    _sum: 'alembic_versionSumAggregateOutput'
    _avg: 'alembic_versionAvgAggregateOutput'
    _min: 'alembic_versionMinAggregateOutput'
    _max: 'alembic_versionMaxAggregateOutput'
    _count: 'alembic_versionCountAggregateOutput'


class alembic_versionAvgAggregateOutput(TypedDict, total=False):
    """alembic_version output for aggregating averages"""


class alembic_versionSumAggregateOutput(TypedDict, total=False):
    """alembic_version output for aggregating sums"""


class alembic_versionScalarAggregateOutput(TypedDict, total=False):
    """alembic_version output including scalar fields"""
    version_num: _str


alembic_versionMinAggregateOutput = alembic_versionScalarAggregateOutput
alembic_versionMaxAggregateOutput = alembic_versionScalarAggregateOutput


class alembic_versionMaxAggregateInput(TypedDict, total=False):
    """alembic_version input for aggregating by max"""
    version_num: bool


class alembic_versionMinAggregateInput(TypedDict, total=False):
    """alembic_version input for aggregating by min"""
    version_num: bool


class alembic_versionNumberAggregateInput(TypedDict, total=False):
    """alembic_version input for aggregating numbers"""


alembic_versionAvgAggregateInput = alembic_versionNumberAggregateInput
alembic_versionSumAggregateInput = alembic_versionNumberAggregateInput


class alembic_versionCountAggregateInput(TypedDict, total=False):
    version_num: bool
    _all: bool

class alembic_versionCountAggregateOutput(TypedDict, total=False):
    version_num: int
    _all: int


alembic_versionKeys = Literal[
    'version_num',
]
alembic_versionScalarFieldKeys = Literal[
    'version_num',
]
alembic_versionScalarFieldKeysT = TypeVar('alembic_versionScalarFieldKeysT', bound=alembic_versionScalarFieldKeys)

alembic_versionRelationalFieldKeys = _NoneType

# license types

class licenseOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the license create method"""
    product_id: _str
    owner_id: _str | None
    activated_at: datetime.datetime | None
    expired_at: datetime.datetime | None
    users: 'usersCreateNestedWithoutRelationsInput'
    products: 'productsCreateNestedWithoutRelationsInput'


class licenseCreateInput(licenseOptionalCreateInput):
    """Required arguments to the license create method"""
    key: _str
    id: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class licenseOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the license create method, without relations"""
    product_id: _str
    owner_id: _str | None
    activated_at: datetime.datetime | None
    expired_at: datetime.datetime | None


class licenseCreateWithoutRelationsInput(licenseOptionalCreateWithoutRelationsInput):
    """Required arguments to the license create method, without relations"""
    key: _str
    id: _str

class licenseConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'licenseCreateWithoutRelationsInput'
    where: 'licenseWhereUniqueInput'

class licenseCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'licenseCreateWithoutRelationsInput'
    connect: 'licenseWhereUniqueInput'
    connect_or_create: 'licenseConnectOrCreateWithoutRelationsInput'


class licenseCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['licenseCreateWithoutRelationsInput', list['licenseCreateWithoutRelationsInput']]
    connect: Union['licenseWhereUniqueInput', list['licenseWhereUniqueInput']]
    connect_or_create: Union['licenseConnectOrCreateWithoutRelationsInput', list['licenseConnectOrCreateWithoutRelationsInput']]

class _licenseCompoundPrimaryKeyInner(TypedDict, total=True):
    key: '_str'
    id: '_str'

class _licenseCompoundPrimaryKey(TypedDict, total=True):
    key_id: '_licenseCompoundPrimaryKeyInner'

licenseWhereUniqueInput = _licenseCompoundPrimaryKey


class licenseUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    key: _str
    activated_at: datetime.datetime | None
    expired_at: datetime.datetime | None
    id: _str
    users: 'usersUpdateOneWithoutRelationsInput'
    products: 'productsUpdateOneWithoutRelationsInput'


class licenseUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    key: _str
    activated_at: datetime.datetime | None
    expired_at: datetime.datetime | None
    id: _str


class licenseUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: list['licenseCreateWithoutRelationsInput']
    connect: list['licenseWhereUniqueInput']
    connect_or_create: list['licenseConnectOrCreateWithoutRelationsInput']
    set: list['licenseWhereUniqueInput']
    disconnect: list['licenseWhereUniqueInput']
    delete: list['licenseWhereUniqueInput']

    # TODO
    # update: List['licenseUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['licenseUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['licenseScalarWhereInput']
    # upsert: List['licenseUpserteWithWhereUniqueWithoutRelationsInput']


class licenseUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'licenseCreateWithoutRelationsInput'
    connect: 'licenseWhereUniqueInput'
    connect_or_create: 'licenseConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'licenseUpdateInput'
    # upsert: 'licenseUpsertWithoutRelationsInput'


class licenseUpsertInput(TypedDict):
    create: 'licenseCreateInput'
    update: 'licenseUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


class _license_key_OrderByInput(TypedDict, total=True):
    key: 'SortOrder'

class _license_product_id_OrderByInput(TypedDict, total=True):
    product_id: 'SortOrder'

class _license_owner_id_OrderByInput(TypedDict, total=True):
    owner_id: 'SortOrder'

class _license_activated_at_OrderByInput(TypedDict, total=True):
    activated_at: 'SortOrder'

class _license_expired_at_OrderByInput(TypedDict, total=True):
    expired_at: 'SortOrder'

class _license_id_OrderByInput(TypedDict, total=True):
    id: 'SortOrder'

class _license_RelevanceInner(TypedDict, total=True):
    fields: 'list[licenseScalarFieldKeys]'
    search: 'str'
    sort: 'SortOrder'

class _license_RelevanceOrderByInput(TypedDict, total=True):
    _relevance: '_license_RelevanceInner'

licenseOrderByInput = Union[
    '_license_key_OrderByInput',
    '_license_product_id_OrderByInput',
    '_license_owner_id_OrderByInput',
    '_license_activated_at_OrderByInput',
    '_license_expired_at_OrderByInput',
    '_license_id_OrderByInput',
    '_license_RelevanceOrderByInput',
]



# recursive license types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

licenseRelationFilter = TypedDict(
    'licenseRelationFilter',
    {
        'is': 'dict[str, Any]',
        'is_not': 'dict[str, Any]',
    },
    total=False,
)


class licenseListRelationFilter(TypedDict, total=False):
    some: 'dict[str, Any]'
    none: 'dict[str, Any]'
    every: 'dict[str, Any]'


class licenseInclude(TypedDict, total=False):
    """license relational arguments"""
    users: Union[bool, 'usersArgsFromlicense']
    products: Union[bool, 'productsArgsFromlicense']


    

class alembic_versionIncludeFromlicense(TypedDict, total=False):
    """Relational arguments for license"""


class alembic_versionIncludeFromlicenseRecursive1(TypedDict, total=False):
    """Relational arguments for license"""


class alembic_versionIncludeFromlicenseRecursive2(TypedDict, total=False):
    """Relational arguments for license"""


class alembic_versionIncludeFromlicenseRecursive3(TypedDict, total=False):
    """Relational arguments for license"""


class alembic_versionIncludeFromlicenseRecursive4(TypedDict, total=False):
    """Relational arguments for license"""

    

class alembic_versionArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class alembic_versionArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class alembic_versionArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class alembic_versionArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class alembic_versionArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    
    

class FindManyalembic_versionArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class FindManyalembic_versionArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class FindManyalembic_versionArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class FindManyalembic_versionArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class FindManyalembic_versionArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    
    

class licenseIncludeFromlicense(TypedDict, total=False):
    """Relational arguments for license"""
    users: Union[bool, 'usersArgsFromlicenseRecursive1']
    products: Union[bool, 'productsArgsFromlicenseRecursive1']


class licenseIncludeFromlicenseRecursive1(TypedDict, total=False):
    """Relational arguments for license"""
    users: Union[bool, 'usersArgsFromlicenseRecursive2']
    products: Union[bool, 'productsArgsFromlicenseRecursive2']


class licenseIncludeFromlicenseRecursive2(TypedDict, total=False):
    """Relational arguments for license"""
    users: Union[bool, 'usersArgsFromlicenseRecursive3']
    products: Union[bool, 'productsArgsFromlicenseRecursive3']


class licenseIncludeFromlicenseRecursive3(TypedDict, total=False):
    """Relational arguments for license"""
    users: Union[bool, 'usersArgsFromlicenseRecursive4']
    products: Union[bool, 'productsArgsFromlicenseRecursive4']


class licenseIncludeFromlicenseRecursive4(TypedDict, total=False):
    """Relational arguments for license"""

    

class licenseArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    include: 'licenseIncludeFromlicenseRecursive1'


class licenseArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    include: 'licenseIncludeFromlicenseRecursive2'


class licenseArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    include: 'licenseIncludeFromlicenseRecursive3'


class licenseArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    include: 'licenseIncludeFromlicenseRecursive4'


class licenseArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    
    

class FindManylicenseArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive1'


class FindManylicenseArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive2'


class FindManylicenseArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive3'


class FindManylicenseArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive4'


class FindManylicenseArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    
    

class productsIncludeFromlicense(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive1']


class productsIncludeFromlicenseRecursive1(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive2']


class productsIncludeFromlicenseRecursive2(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive3']


class productsIncludeFromlicenseRecursive3(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive4']


class productsIncludeFromlicenseRecursive4(TypedDict, total=False):
    """Relational arguments for license"""

    

class productsArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    include: 'productsIncludeFromproductsRecursive1'


class productsArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    include: 'productsIncludeFromproductsRecursive2'


class productsArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    include: 'productsIncludeFromproductsRecursive3'


class productsArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    include: 'productsIncludeFromproductsRecursive4'


class productsArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    
    

class FindManyproductsArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive1'


class FindManyproductsArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive2'


class FindManyproductsArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive3'


class FindManyproductsArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive4'


class FindManyproductsArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    
    

class usersIncludeFromlicense(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive1']


class usersIncludeFromlicenseRecursive1(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive2']


class usersIncludeFromlicenseRecursive2(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive3']


class usersIncludeFromlicenseRecursive3(TypedDict, total=False):
    """Relational arguments for license"""
    licenses: Union[bool, 'FindManylicenseArgsFromlicenseRecursive4']


class usersIncludeFromlicenseRecursive4(TypedDict, total=False):
    """Relational arguments for license"""

    

class usersArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    include: 'usersIncludeFromusersRecursive1'


class usersArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    include: 'usersIncludeFromusersRecursive2'


class usersArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    include: 'usersIncludeFromusersRecursive3'


class usersArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    include: 'usersIncludeFromusersRecursive4'


class usersArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    
    

class FindManyusersArgsFromlicense(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive1'


class FindManyusersArgsFromlicenseRecursive1(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive2'


class FindManyusersArgsFromlicenseRecursive2(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive3'


class FindManyusersArgsFromlicenseRecursive3(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive4'


class FindManyusersArgsFromlicenseRecursive4(TypedDict, total=False):
    """Arguments for license"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    


FindManylicenseArgs = FindManylicenseArgsFromlicense
FindFirstlicenseArgs = FindManylicenseArgsFromlicense


    

class licenseWhereInput(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringFilter']
    product_id: Union[_str, 'types.StringFilter']
    owner_id: Union[None, _str, 'types.StringFilter']
    activated_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    expired_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    id: Union[_str, 'types.StringFilter']
    users: 'usersRelationFilter'
    products: 'productsRelationFilter'

    # should be noted that AND and NOT should be Union['licenseWhereInputRecursive1', List['licenseWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: list['licenseWhereInputRecursive1']
    OR: list['licenseWhereInputRecursive1']
    NOT: list['licenseWhereInputRecursive1']


class licenseWhereInputRecursive1(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringFilter']
    product_id: Union[_str, 'types.StringFilter']
    owner_id: Union[None, _str, 'types.StringFilter']
    activated_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    expired_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    id: Union[_str, 'types.StringFilter']
    users: 'usersRelationFilter'
    products: 'productsRelationFilter'

    # should be noted that AND and NOT should be Union['licenseWhereInputRecursive2', List['licenseWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: list['licenseWhereInputRecursive2']
    OR: list['licenseWhereInputRecursive2']
    NOT: list['licenseWhereInputRecursive2']


class licenseWhereInputRecursive2(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringFilter']
    product_id: Union[_str, 'types.StringFilter']
    owner_id: Union[None, _str, 'types.StringFilter']
    activated_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    expired_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    id: Union[_str, 'types.StringFilter']
    users: 'usersRelationFilter'
    products: 'productsRelationFilter'

    # should be noted that AND and NOT should be Union['licenseWhereInputRecursive3', List['licenseWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: list['licenseWhereInputRecursive3']
    OR: list['licenseWhereInputRecursive3']
    NOT: list['licenseWhereInputRecursive3']


class licenseWhereInputRecursive3(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringFilter']
    product_id: Union[_str, 'types.StringFilter']
    owner_id: Union[None, _str, 'types.StringFilter']
    activated_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    expired_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    id: Union[_str, 'types.StringFilter']
    users: 'usersRelationFilter'
    products: 'productsRelationFilter'

    # should be noted that AND and NOT should be Union['licenseWhereInputRecursive4', List['licenseWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: list['licenseWhereInputRecursive4']
    OR: list['licenseWhereInputRecursive4']
    NOT: list['licenseWhereInputRecursive4']


class licenseWhereInputRecursive4(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringFilter']
    product_id: Union[_str, 'types.StringFilter']
    owner_id: Union[None, _str, 'types.StringFilter']
    activated_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    expired_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    id: Union[_str, 'types.StringFilter']
    users: 'usersRelationFilter'
    products: 'productsRelationFilter'



# aggregate license types


    

class licenseScalarWhereWithAggregatesInput(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    owner_id: Union[_str, 'types.StringWithAggregatesFilter']
    activated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    expired_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['licenseScalarWhereWithAggregatesInputRecursive1']
    OR: list['licenseScalarWhereWithAggregatesInputRecursive1']
    NOT: list['licenseScalarWhereWithAggregatesInputRecursive1']


class licenseScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    owner_id: Union[_str, 'types.StringWithAggregatesFilter']
    activated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    expired_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['licenseScalarWhereWithAggregatesInputRecursive2']
    OR: list['licenseScalarWhereWithAggregatesInputRecursive2']
    NOT: list['licenseScalarWhereWithAggregatesInputRecursive2']


class licenseScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    owner_id: Union[_str, 'types.StringWithAggregatesFilter']
    activated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    expired_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['licenseScalarWhereWithAggregatesInputRecursive3']
    OR: list['licenseScalarWhereWithAggregatesInputRecursive3']
    NOT: list['licenseScalarWhereWithAggregatesInputRecursive3']


class licenseScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    owner_id: Union[_str, 'types.StringWithAggregatesFilter']
    activated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    expired_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['licenseScalarWhereWithAggregatesInputRecursive4']
    OR: list['licenseScalarWhereWithAggregatesInputRecursive4']
    NOT: list['licenseScalarWhereWithAggregatesInputRecursive4']


class licenseScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """license arguments for searching"""
    key: Union[_str, 'types.StringWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    owner_id: Union[_str, 'types.StringWithAggregatesFilter']
    activated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    expired_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']



class licenseGroupByOutput(TypedDict, total=False):
    key: _str
    product_id: _str
    owner_id: _str
    activated_at: datetime.datetime
    expired_at: datetime.datetime
    id: _str
    _sum: 'licenseSumAggregateOutput'
    _avg: 'licenseAvgAggregateOutput'
    _min: 'licenseMinAggregateOutput'
    _max: 'licenseMaxAggregateOutput'
    _count: 'licenseCountAggregateOutput'


class licenseAvgAggregateOutput(TypedDict, total=False):
    """license output for aggregating averages"""


class licenseSumAggregateOutput(TypedDict, total=False):
    """license output for aggregating sums"""


class licenseScalarAggregateOutput(TypedDict, total=False):
    """license output including scalar fields"""
    key: _str
    product_id: _str
    owner_id: _str
    activated_at: datetime.datetime
    expired_at: datetime.datetime
    id: _str


licenseMinAggregateOutput = licenseScalarAggregateOutput
licenseMaxAggregateOutput = licenseScalarAggregateOutput


class licenseMaxAggregateInput(TypedDict, total=False):
    """license input for aggregating by max"""
    key: bool
    product_id: bool
    owner_id: bool
    activated_at: bool
    expired_at: bool
    id: bool


class licenseMinAggregateInput(TypedDict, total=False):
    """license input for aggregating by min"""
    key: bool
    product_id: bool
    owner_id: bool
    activated_at: bool
    expired_at: bool
    id: bool


class licenseNumberAggregateInput(TypedDict, total=False):
    """license input for aggregating numbers"""


licenseAvgAggregateInput = licenseNumberAggregateInput
licenseSumAggregateInput = licenseNumberAggregateInput


class licenseCountAggregateInput(TypedDict, total=False):
    key: bool
    product_id: bool
    owner_id: bool
    activated_at: bool
    expired_at: bool
    id: bool
    _all: bool

class licenseCountAggregateOutput(TypedDict, total=False):
    key: int
    product_id: int
    owner_id: int
    activated_at: int
    expired_at: int
    id: int
    _all: int


licenseKeys = Literal[
    'key',
    'product_id',
    'owner_id',
    'activated_at',
    'expired_at',
    'id',
    'users',
    'products',
]
licenseScalarFieldKeys = Literal[
    'key',
    'product_id',
    'owner_id',
    'activated_at',
    'expired_at',
    'id',
]
licenseScalarFieldKeysT = TypeVar('licenseScalarFieldKeysT', bound=licenseScalarFieldKeys)

licenseRelationalFieldKeys = Literal[
        'users',
        'products',
    ]

# products types

class productsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the products create method"""
    licenses: 'licenseCreateManyNestedWithoutRelationsInput'


class productsCreateInput(productsOptionalCreateInput):
    """Required arguments to the products create method"""
    type: 'enums.productstypeenum'
    duration_days: _int
    id: _str
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class productsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the products create method, without relations"""


class productsCreateWithoutRelationsInput(productsOptionalCreateWithoutRelationsInput):
    """Required arguments to the products create method, without relations"""
    type: 'enums.productstypeenum'
    duration_days: _int
    id: _str
    name: _str

class productsConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'productsCreateWithoutRelationsInput'
    where: 'productsWhereUniqueInput'

class productsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'productsCreateWithoutRelationsInput'
    connect: 'productsWhereUniqueInput'
    connect_or_create: 'productsConnectOrCreateWithoutRelationsInput'


class productsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['productsCreateWithoutRelationsInput', list['productsCreateWithoutRelationsInput']]
    connect: Union['productsWhereUniqueInput', list['productsWhereUniqueInput']]
    connect_or_create: Union['productsConnectOrCreateWithoutRelationsInput', list['productsConnectOrCreateWithoutRelationsInput']]

class _productsWhereUnique_id_Input(TypedDict, total=True):
    id: '_str'

productsWhereUniqueInput = _productsWhereUnique_id_Input


class productsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    type: 'enums.productstypeenum'
    duration_days: AtomicIntInput | _int
    id: _str
    name: _str
    licenses: 'licenseUpdateManyWithoutRelationsInput'


class productsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    type: 'enums.productstypeenum'
    duration_days: AtomicIntInput | _int
    id: _str
    name: _str


class productsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: list['productsCreateWithoutRelationsInput']
    connect: list['productsWhereUniqueInput']
    connect_or_create: list['productsConnectOrCreateWithoutRelationsInput']
    set: list['productsWhereUniqueInput']
    disconnect: list['productsWhereUniqueInput']
    delete: list['productsWhereUniqueInput']

    # TODO
    # update: List['productsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['productsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['productsScalarWhereInput']
    # upsert: List['productsUpserteWithWhereUniqueWithoutRelationsInput']


class productsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'productsCreateWithoutRelationsInput'
    connect: 'productsWhereUniqueInput'
    connect_or_create: 'productsConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'productsUpdateInput'
    # upsert: 'productsUpsertWithoutRelationsInput'


class productsUpsertInput(TypedDict):
    create: 'productsCreateInput'
    update: 'productsUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


class _products_type_OrderByInput(TypedDict, total=True):
    type: 'SortOrder'

class _products_duration_days_OrderByInput(TypedDict, total=True):
    duration_days: 'SortOrder'

class _products_id_OrderByInput(TypedDict, total=True):
    id: 'SortOrder'

class _products_name_OrderByInput(TypedDict, total=True):
    name: 'SortOrder'

class _products_RelevanceInner(TypedDict, total=True):
    fields: 'list[productsScalarFieldKeys]'
    search: 'str'
    sort: 'SortOrder'

class _products_RelevanceOrderByInput(TypedDict, total=True):
    _relevance: '_products_RelevanceInner'

productsOrderByInput = Union[
    '_products_type_OrderByInput',
    '_products_duration_days_OrderByInput',
    '_products_id_OrderByInput',
    '_products_name_OrderByInput',
    '_products_RelevanceOrderByInput',
]



# recursive products types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

productsRelationFilter = TypedDict(
    'productsRelationFilter',
    {
        'is': 'dict[str, Any]',
        'is_not': 'dict[str, Any]',
    },
    total=False,
)


class productsListRelationFilter(TypedDict, total=False):
    some: 'dict[str, Any]'
    none: 'dict[str, Any]'
    every: 'dict[str, Any]'


class productsInclude(TypedDict, total=False):
    """products relational arguments"""
    licenses: Union[bool, 'FindManylicenseArgsFromproducts']


    

class alembic_versionIncludeFromproducts(TypedDict, total=False):
    """Relational arguments for products"""


class alembic_versionIncludeFromproductsRecursive1(TypedDict, total=False):
    """Relational arguments for products"""


class alembic_versionIncludeFromproductsRecursive2(TypedDict, total=False):
    """Relational arguments for products"""


class alembic_versionIncludeFromproductsRecursive3(TypedDict, total=False):
    """Relational arguments for products"""


class alembic_versionIncludeFromproductsRecursive4(TypedDict, total=False):
    """Relational arguments for products"""

    

class alembic_versionArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class alembic_versionArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class alembic_versionArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class alembic_versionArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class alembic_versionArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    
    

class FindManyalembic_versionArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class FindManyalembic_versionArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class FindManyalembic_versionArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class FindManyalembic_versionArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class FindManyalembic_versionArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    
    

class licenseIncludeFromproducts(TypedDict, total=False):
    """Relational arguments for products"""
    users: Union[bool, 'usersArgsFromproductsRecursive1']
    products: Union[bool, 'productsArgsFromproductsRecursive1']


class licenseIncludeFromproductsRecursive1(TypedDict, total=False):
    """Relational arguments for products"""
    users: Union[bool, 'usersArgsFromproductsRecursive2']
    products: Union[bool, 'productsArgsFromproductsRecursive2']


class licenseIncludeFromproductsRecursive2(TypedDict, total=False):
    """Relational arguments for products"""
    users: Union[bool, 'usersArgsFromproductsRecursive3']
    products: Union[bool, 'productsArgsFromproductsRecursive3']


class licenseIncludeFromproductsRecursive3(TypedDict, total=False):
    """Relational arguments for products"""
    users: Union[bool, 'usersArgsFromproductsRecursive4']
    products: Union[bool, 'productsArgsFromproductsRecursive4']


class licenseIncludeFromproductsRecursive4(TypedDict, total=False):
    """Relational arguments for products"""

    

class licenseArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    include: 'licenseIncludeFromlicenseRecursive1'


class licenseArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    include: 'licenseIncludeFromlicenseRecursive2'


class licenseArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    include: 'licenseIncludeFromlicenseRecursive3'


class licenseArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    include: 'licenseIncludeFromlicenseRecursive4'


class licenseArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    
    

class FindManylicenseArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive1'


class FindManylicenseArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive2'


class FindManylicenseArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive3'


class FindManylicenseArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive4'


class FindManylicenseArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    
    

class productsIncludeFromproducts(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive1']


class productsIncludeFromproductsRecursive1(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive2']


class productsIncludeFromproductsRecursive2(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive3']


class productsIncludeFromproductsRecursive3(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive4']


class productsIncludeFromproductsRecursive4(TypedDict, total=False):
    """Relational arguments for products"""

    

class productsArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    include: 'productsIncludeFromproductsRecursive1'


class productsArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    include: 'productsIncludeFromproductsRecursive2'


class productsArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    include: 'productsIncludeFromproductsRecursive3'


class productsArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    include: 'productsIncludeFromproductsRecursive4'


class productsArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    
    

class FindManyproductsArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive1'


class FindManyproductsArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive2'


class FindManyproductsArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive3'


class FindManyproductsArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive4'


class FindManyproductsArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    
    

class usersIncludeFromproducts(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive1']


class usersIncludeFromproductsRecursive1(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive2']


class usersIncludeFromproductsRecursive2(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive3']


class usersIncludeFromproductsRecursive3(TypedDict, total=False):
    """Relational arguments for products"""
    licenses: Union[bool, 'FindManylicenseArgsFromproductsRecursive4']


class usersIncludeFromproductsRecursive4(TypedDict, total=False):
    """Relational arguments for products"""

    

class usersArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    include: 'usersIncludeFromusersRecursive1'


class usersArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    include: 'usersIncludeFromusersRecursive2'


class usersArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    include: 'usersIncludeFromusersRecursive3'


class usersArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    include: 'usersIncludeFromusersRecursive4'


class usersArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    
    

class FindManyusersArgsFromproducts(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive1'


class FindManyusersArgsFromproductsRecursive1(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive2'


class FindManyusersArgsFromproductsRecursive2(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive3'


class FindManyusersArgsFromproductsRecursive3(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive4'


class FindManyusersArgsFromproductsRecursive4(TypedDict, total=False):
    """Arguments for products"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    


FindManyproductsArgs = FindManyproductsArgsFromproducts
FindFirstproductsArgs = FindManyproductsArgsFromproducts


    

class productsWhereInput(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntFilter']
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['productsWhereInputRecursive1', List['productsWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: list['productsWhereInputRecursive1']
    OR: list['productsWhereInputRecursive1']
    NOT: list['productsWhereInputRecursive1']


class productsWhereInputRecursive1(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntFilter']
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['productsWhereInputRecursive2', List['productsWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: list['productsWhereInputRecursive2']
    OR: list['productsWhereInputRecursive2']
    NOT: list['productsWhereInputRecursive2']


class productsWhereInputRecursive2(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntFilter']
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['productsWhereInputRecursive3', List['productsWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: list['productsWhereInputRecursive3']
    OR: list['productsWhereInputRecursive3']
    NOT: list['productsWhereInputRecursive3']


class productsWhereInputRecursive3(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntFilter']
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['productsWhereInputRecursive4', List['productsWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: list['productsWhereInputRecursive4']
    OR: list['productsWhereInputRecursive4']
    NOT: list['productsWhereInputRecursive4']


class productsWhereInputRecursive4(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntFilter']
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'



# aggregate products types


    

class productsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['productsScalarWhereWithAggregatesInputRecursive1']
    OR: list['productsScalarWhereWithAggregatesInputRecursive1']
    NOT: list['productsScalarWhereWithAggregatesInputRecursive1']


class productsScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['productsScalarWhereWithAggregatesInputRecursive2']
    OR: list['productsScalarWhereWithAggregatesInputRecursive2']
    NOT: list['productsScalarWhereWithAggregatesInputRecursive2']


class productsScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['productsScalarWhereWithAggregatesInputRecursive3']
    OR: list['productsScalarWhereWithAggregatesInputRecursive3']
    NOT: list['productsScalarWhereWithAggregatesInputRecursive3']


class productsScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['productsScalarWhereWithAggregatesInputRecursive4']
    OR: list['productsScalarWhereWithAggregatesInputRecursive4']
    NOT: list['productsScalarWhereWithAggregatesInputRecursive4']


class productsScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """products arguments for searching"""
    type: 'enums.productstypeenum'
    duration_days: Union[_int, 'types.IntWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']



class productsGroupByOutput(TypedDict, total=False):
    type: 'enums.productstypeenum'
    duration_days: _int
    id: _str
    name: _str
    _sum: 'productsSumAggregateOutput'
    _avg: 'productsAvgAggregateOutput'
    _min: 'productsMinAggregateOutput'
    _max: 'productsMaxAggregateOutput'
    _count: 'productsCountAggregateOutput'


class productsAvgAggregateOutput(TypedDict, total=False):
    """products output for aggregating averages"""
    duration_days: float


class productsSumAggregateOutput(TypedDict, total=False):
    """products output for aggregating sums"""
    duration_days: _int


class productsScalarAggregateOutput(TypedDict, total=False):
    """products output including scalar fields"""
    type: 'enums.productstypeenum'
    duration_days: _int
    id: _str
    name: _str


productsMinAggregateOutput = productsScalarAggregateOutput
productsMaxAggregateOutput = productsScalarAggregateOutput


class productsMaxAggregateInput(TypedDict, total=False):
    """products input for aggregating by max"""
    type: bool
    duration_days: bool
    id: bool
    name: bool


class productsMinAggregateInput(TypedDict, total=False):
    """products input for aggregating by min"""
    type: bool
    duration_days: bool
    id: bool
    name: bool


class productsNumberAggregateInput(TypedDict, total=False):
    """products input for aggregating numbers"""
    duration_days: bool


productsAvgAggregateInput = productsNumberAggregateInput
productsSumAggregateInput = productsNumberAggregateInput


class productsCountAggregateInput(TypedDict, total=False):
    type: bool
    duration_days: bool
    id: bool
    name: bool
    _all: bool

class productsCountAggregateOutput(TypedDict, total=False):
    type: int
    duration_days: int
    id: int
    name: int
    _all: int


productsKeys = Literal[
    'type',
    'duration_days',
    'id',
    'name',
    'licenses',
]
productsScalarFieldKeys = Literal[
    'type',
    'duration_days',
    'id',
    'name',
]
productsScalarFieldKeysT = TypeVar('productsScalarFieldKeysT', bound=productsScalarFieldKeys)

productsRelationalFieldKeys = Literal[
        'licenses',
    ]

# users types

class usersOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the users create method"""
    licenses: 'licenseCreateManyNestedWithoutRelationsInput'


class usersCreateInput(usersOptionalCreateInput):
    """Required arguments to the users create method"""
    username: _str
    email: _str
    id: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class usersOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the users create method, without relations"""


class usersCreateWithoutRelationsInput(usersOptionalCreateWithoutRelationsInput):
    """Required arguments to the users create method, without relations"""
    username: _str
    email: _str
    id: _str

class usersConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'usersCreateWithoutRelationsInput'
    where: 'usersWhereUniqueInput'

class usersCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'usersCreateWithoutRelationsInput'
    connect: 'usersWhereUniqueInput'
    connect_or_create: 'usersConnectOrCreateWithoutRelationsInput'


class usersCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['usersCreateWithoutRelationsInput', list['usersCreateWithoutRelationsInput']]
    connect: Union['usersWhereUniqueInput', list['usersWhereUniqueInput']]
    connect_or_create: Union['usersConnectOrCreateWithoutRelationsInput', list['usersConnectOrCreateWithoutRelationsInput']]

class _usersWhereUnique_username_Input(TypedDict, total=True):
    username: '_str'

class _usersWhereUnique_email_Input(TypedDict, total=True):
    email: '_str'

class _usersWhereUnique_id_Input(TypedDict, total=True):
    id: '_str'

usersWhereUniqueInput = Union[
    '_usersWhereUnique_username_Input',
    '_usersWhereUnique_email_Input',
    '_usersWhereUnique_id_Input',
]


class usersUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    username: _str
    email: _str
    id: _str
    licenses: 'licenseUpdateManyWithoutRelationsInput'


class usersUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    username: _str
    email: _str
    id: _str


class usersUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: list['usersCreateWithoutRelationsInput']
    connect: list['usersWhereUniqueInput']
    connect_or_create: list['usersConnectOrCreateWithoutRelationsInput']
    set: list['usersWhereUniqueInput']
    disconnect: list['usersWhereUniqueInput']
    delete: list['usersWhereUniqueInput']

    # TODO
    # update: List['usersUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['usersUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['usersScalarWhereInput']
    # upsert: List['usersUpserteWithWhereUniqueWithoutRelationsInput']


class usersUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'usersCreateWithoutRelationsInput'
    connect: 'usersWhereUniqueInput'
    connect_or_create: 'usersConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'usersUpdateInput'
    # upsert: 'usersUpsertWithoutRelationsInput'


class usersUpsertInput(TypedDict):
    create: 'usersCreateInput'
    update: 'usersUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


class _users_username_OrderByInput(TypedDict, total=True):
    username: 'SortOrder'

class _users_email_OrderByInput(TypedDict, total=True):
    email: 'SortOrder'

class _users_id_OrderByInput(TypedDict, total=True):
    id: 'SortOrder'

class _users_RelevanceInner(TypedDict, total=True):
    fields: 'list[usersScalarFieldKeys]'
    search: 'str'
    sort: 'SortOrder'

class _users_RelevanceOrderByInput(TypedDict, total=True):
    _relevance: '_users_RelevanceInner'

usersOrderByInput = Union[
    '_users_username_OrderByInput',
    '_users_email_OrderByInput',
    '_users_id_OrderByInput',
    '_users_RelevanceOrderByInput',
]



# recursive users types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

usersRelationFilter = TypedDict(
    'usersRelationFilter',
    {
        'is': 'dict[str, Any]',
        'is_not': 'dict[str, Any]',
    },
    total=False,
)


class usersListRelationFilter(TypedDict, total=False):
    some: 'dict[str, Any]'
    none: 'dict[str, Any]'
    every: 'dict[str, Any]'


class usersInclude(TypedDict, total=False):
    """users relational arguments"""
    licenses: Union[bool, 'FindManylicenseArgsFromusers']


    

class alembic_versionIncludeFromusers(TypedDict, total=False):
    """Relational arguments for users"""


class alembic_versionIncludeFromusersRecursive1(TypedDict, total=False):
    """Relational arguments for users"""


class alembic_versionIncludeFromusersRecursive2(TypedDict, total=False):
    """Relational arguments for users"""


class alembic_versionIncludeFromusersRecursive3(TypedDict, total=False):
    """Relational arguments for users"""


class alembic_versionIncludeFromusersRecursive4(TypedDict, total=False):
    """Relational arguments for users"""

    

class alembic_versionArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class alembic_versionArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class alembic_versionArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class alembic_versionArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class alembic_versionArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    
    

class FindManyalembic_versionArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive1'


class FindManyalembic_versionArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive2'


class FindManyalembic_versionArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive3'


class FindManyalembic_versionArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    include: 'alembic_versionIncludeFromalembic_versionRecursive4'


class FindManyalembic_versionArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['alembic_versionOrderByInput', list['alembic_versionOrderByInput']]
    where: 'alembic_versionWhereInput'
    cursor: 'alembic_versionWhereUniqueInput'
    distinct: list['alembic_versionScalarFieldKeys']
    
    

class licenseIncludeFromusers(TypedDict, total=False):
    """Relational arguments for users"""
    users: Union[bool, 'usersArgsFromusersRecursive1']
    products: Union[bool, 'productsArgsFromusersRecursive1']


class licenseIncludeFromusersRecursive1(TypedDict, total=False):
    """Relational arguments for users"""
    users: Union[bool, 'usersArgsFromusersRecursive2']
    products: Union[bool, 'productsArgsFromusersRecursive2']


class licenseIncludeFromusersRecursive2(TypedDict, total=False):
    """Relational arguments for users"""
    users: Union[bool, 'usersArgsFromusersRecursive3']
    products: Union[bool, 'productsArgsFromusersRecursive3']


class licenseIncludeFromusersRecursive3(TypedDict, total=False):
    """Relational arguments for users"""
    users: Union[bool, 'usersArgsFromusersRecursive4']
    products: Union[bool, 'productsArgsFromusersRecursive4']


class licenseIncludeFromusersRecursive4(TypedDict, total=False):
    """Relational arguments for users"""

    

class licenseArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    include: 'licenseIncludeFromlicenseRecursive1'


class licenseArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    include: 'licenseIncludeFromlicenseRecursive2'


class licenseArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    include: 'licenseIncludeFromlicenseRecursive3'


class licenseArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    include: 'licenseIncludeFromlicenseRecursive4'


class licenseArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    
    

class FindManylicenseArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive1'


class FindManylicenseArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive2'


class FindManylicenseArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive3'


class FindManylicenseArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    include: 'licenseIncludeFromlicenseRecursive4'


class FindManylicenseArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['licenseOrderByInput', list['licenseOrderByInput']]
    where: 'licenseWhereInput'
    cursor: 'licenseWhereUniqueInput'
    distinct: list['licenseScalarFieldKeys']
    
    

class productsIncludeFromusers(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive1']


class productsIncludeFromusersRecursive1(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive2']


class productsIncludeFromusersRecursive2(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive3']


class productsIncludeFromusersRecursive3(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive4']


class productsIncludeFromusersRecursive4(TypedDict, total=False):
    """Relational arguments for users"""

    

class productsArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    include: 'productsIncludeFromproductsRecursive1'


class productsArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    include: 'productsIncludeFromproductsRecursive2'


class productsArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    include: 'productsIncludeFromproductsRecursive3'


class productsArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    include: 'productsIncludeFromproductsRecursive4'


class productsArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    
    

class FindManyproductsArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive1'


class FindManyproductsArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive2'


class FindManyproductsArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive3'


class FindManyproductsArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    include: 'productsIncludeFromproductsRecursive4'


class FindManyproductsArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['productsOrderByInput', list['productsOrderByInput']]
    where: 'productsWhereInput'
    cursor: 'productsWhereUniqueInput'
    distinct: list['productsScalarFieldKeys']
    
    

class usersIncludeFromusers(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive1']


class usersIncludeFromusersRecursive1(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive2']


class usersIncludeFromusersRecursive2(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive3']


class usersIncludeFromusersRecursive3(TypedDict, total=False):
    """Relational arguments for users"""
    licenses: Union[bool, 'FindManylicenseArgsFromusersRecursive4']


class usersIncludeFromusersRecursive4(TypedDict, total=False):
    """Relational arguments for users"""

    

class usersArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    include: 'usersIncludeFromusersRecursive1'


class usersArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    include: 'usersIncludeFromusersRecursive2'


class usersArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    include: 'usersIncludeFromusersRecursive3'


class usersArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    include: 'usersIncludeFromusersRecursive4'


class usersArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    
    

class FindManyusersArgsFromusers(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive1'


class FindManyusersArgsFromusersRecursive1(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive2'


class FindManyusersArgsFromusersRecursive2(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive3'


class FindManyusersArgsFromusersRecursive3(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    include: 'usersIncludeFromusersRecursive4'


class FindManyusersArgsFromusersRecursive4(TypedDict, total=False):
    """Arguments for users"""
    take: int
    skip: int
    order_by: Union['usersOrderByInput', list['usersOrderByInput']]
    where: 'usersWhereInput'
    cursor: 'usersWhereUniqueInput'
    distinct: list['usersScalarFieldKeys']
    


FindManyusersArgs = FindManyusersArgsFromusers
FindFirstusersArgs = FindManyusersArgsFromusers


    

class usersWhereInput(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    id: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['usersWhereInputRecursive1', List['usersWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: list['usersWhereInputRecursive1']
    OR: list['usersWhereInputRecursive1']
    NOT: list['usersWhereInputRecursive1']


class usersWhereInputRecursive1(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    id: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['usersWhereInputRecursive2', List['usersWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: list['usersWhereInputRecursive2']
    OR: list['usersWhereInputRecursive2']
    NOT: list['usersWhereInputRecursive2']


class usersWhereInputRecursive2(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    id: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['usersWhereInputRecursive3', List['usersWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: list['usersWhereInputRecursive3']
    OR: list['usersWhereInputRecursive3']
    NOT: list['usersWhereInputRecursive3']


class usersWhereInputRecursive3(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    id: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'

    # should be noted that AND and NOT should be Union['usersWhereInputRecursive4', List['usersWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: list['usersWhereInputRecursive4']
    OR: list['usersWhereInputRecursive4']
    NOT: list['usersWhereInputRecursive4']


class usersWhereInputRecursive4(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    id: Union[_str, 'types.StringFilter']
    licenses: 'licenseListRelationFilter'



# aggregate users types


    

class usersScalarWhereWithAggregatesInput(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['usersScalarWhereWithAggregatesInputRecursive1']
    OR: list['usersScalarWhereWithAggregatesInputRecursive1']
    NOT: list['usersScalarWhereWithAggregatesInputRecursive1']


class usersScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['usersScalarWhereWithAggregatesInputRecursive2']
    OR: list['usersScalarWhereWithAggregatesInputRecursive2']
    NOT: list['usersScalarWhereWithAggregatesInputRecursive2']


class usersScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['usersScalarWhereWithAggregatesInputRecursive3']
    OR: list['usersScalarWhereWithAggregatesInputRecursive3']
    NOT: list['usersScalarWhereWithAggregatesInputRecursive3']


class usersScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: list['usersScalarWhereWithAggregatesInputRecursive4']
    OR: list['usersScalarWhereWithAggregatesInputRecursive4']
    NOT: list['usersScalarWhereWithAggregatesInputRecursive4']


class usersScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """users arguments for searching"""
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    id: Union[_str, 'types.StringWithAggregatesFilter']



class usersGroupByOutput(TypedDict, total=False):
    username: _str
    email: _str
    id: _str
    _sum: 'usersSumAggregateOutput'
    _avg: 'usersAvgAggregateOutput'
    _min: 'usersMinAggregateOutput'
    _max: 'usersMaxAggregateOutput'
    _count: 'usersCountAggregateOutput'


class usersAvgAggregateOutput(TypedDict, total=False):
    """users output for aggregating averages"""


class usersSumAggregateOutput(TypedDict, total=False):
    """users output for aggregating sums"""


class usersScalarAggregateOutput(TypedDict, total=False):
    """users output including scalar fields"""
    username: _str
    email: _str
    id: _str


usersMinAggregateOutput = usersScalarAggregateOutput
usersMaxAggregateOutput = usersScalarAggregateOutput


class usersMaxAggregateInput(TypedDict, total=False):
    """users input for aggregating by max"""
    username: bool
    email: bool
    id: bool


class usersMinAggregateInput(TypedDict, total=False):
    """users input for aggregating by min"""
    username: bool
    email: bool
    id: bool


class usersNumberAggregateInput(TypedDict, total=False):
    """users input for aggregating numbers"""


usersAvgAggregateInput = usersNumberAggregateInput
usersSumAggregateInput = usersNumberAggregateInput


class usersCountAggregateInput(TypedDict, total=False):
    username: bool
    email: bool
    id: bool
    _all: bool

class usersCountAggregateOutput(TypedDict, total=False):
    username: int
    email: int
    id: int
    _all: int


usersKeys = Literal[
    'username',
    'email',
    'id',
    'licenses',
]
usersScalarFieldKeys = Literal[
    'username',
    'email',
    'id',
]
usersScalarFieldKeysT = TypeVar('usersScalarFieldKeysT', bound=usersScalarFieldKeys)

usersRelationalFieldKeys = Literal[
        'licenses',
    ]



# we have to import ourselves as types can be namespaced to types
from . import enums, fields, types
